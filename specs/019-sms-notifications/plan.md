# Implementation Plan: SMS Notification System

**Branch**: `009-sms-notifications` | **Date**: 2025-10-23 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/019-sms-notifications/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command workflow.

## Summary

SMS notification system provides alternative delivery channel to email, enabling volunteers to receive time-sensitive alerts (assignment requests, schedule changes, reminders) via text messages with 98% open rates and immediate visibility. Core features include Twilio SMS API integration for message delivery, two-way SMS communication for assignment confirmation/declination via YES/NO replies, phone number verification and opt-in/opt-out for TCPA compliance, notification preference management allowing volunteers to select SMS/email per notification type, broadcast messaging for urgent team communications, automatic 24-hour event reminders, rate limiting to prevent spam (max 3 SMS/day per volunteer), quiet hours enforcement (10pm-8am local time), cost tracking with monthly budget limits and 80% usage alerts, message templates with dynamic variable substitution ([event_name], [date], [time]), delivery tracking with retry logic for failed messages, and SMS analytics dashboard showing usage costs and delivery status. Target: 30-second delivery (95th percentile), 250% increase in volunteer response rates, 60% reduction in last-minute schedule gaps, 100% TCPA compliance.

## Technical Context

**Language/Version**: Python 3.11+ (backend), JavaScript ES6+ (frontend preferences UI)
**Primary Dependencies**: Twilio Python SDK 8.0+ (SMS API, Lookup API, webhooks), FastAPI (API endpoints), Celery 5.0+ (async message queue), Redis 7.0+ (Celery broker, rate limiting)
**Storage**: PostgreSQL (message logs, preferences, templates, usage tracking), Redis (rate limit counters, message queue)
**Testing**: Pytest (unit tests for SMS service), Playwright (E2E tests for preference UI), Twilio Test Credentials (sandbox testing without real SMS charges)
**Target Platform**: Backend services (Linux server), Twilio cloud service (SMS delivery)
**Project Type**: Web application (backend SMS service + frontend preference management UI)
**Performance Goals**: <30s SMS delivery (95th percentile), <60s two-way reply processing, 98% delivery success rate, 10 messages/minute batch rate (carrier limits)
**Constraints**: TCPA compliance (explicit opt-in required), rate limiting (3 SMS/day/volunteer), quiet hours (10pm-8am), 160 char recommended message length, cost management (budget alerts at 80%)
**Scale/Scope**: 50-200 messages/day per organization, 10-50 organizations, 100-1000 volunteers per organization, 200+ message templates, 90-day message history retention

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Principle Compliance Analysis**:

✅ **Library-First**: SMS service implemented as standalone `SMSService` class in `api/services/sms_service.py` with clear Twilio integration interface, independently testable with mock SMS gateway for unit tests, documented API for message sending/receiving/tracking.

✅ **Test-First (NON-NEGOTIABLE)**: TDD approach: Write unit tests for SMS service methods (send_message, verify_phone, process_reply, track_delivery) → User approves test coverage → Tests fail (no implementation) → Implement SMS service to make tests pass → Integration tests for Twilio API → E2E tests for preference UI workflows.

✅ **Integration Testing**: Required for: Twilio SMS API contract (send/receive/status webhooks), phone number verification via Lookup API, delivery status webhook processing, Celery task queue integration (async message sending), rate limiting with Redis counters, two-way SMS reply processing.

✅ **Observability**: Structured logging for all SMS operations (message sent, delivered, failed, reply received, opt-out processed) with message IDs for correlation, Twilio webhook event logging for delivery tracking, error logging with detailed Twilio error codes for troubleshooting, cost tracking logs for billing reconciliation.

✅ **Simplicity**: Start with single SMS service class wrapping Twilio client, basic message queue with Celery (avoid complex orchestration initially), simple rate limiting with Redis counters (no distributed rate limiter), manual template management (no template engine), YAGNI: defer advanced features like A/B testing, sentiment analysis, AI-powered message optimization until core functionality proven.

**Gate Status**: ✅ PASS - No constitution violations. SMS service follows established SignUpFlow patterns (service classes in `api/services/`, Celery for async tasks, Redis for caching/queuing, PostgreSQL for persistent storage). Test-first approach mandatory for compliance-critical SMS functionality (TCPA regulations).

## Project Structure

### Documentation (this feature)

```
specs/019-sms-notifications/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (SMS gateway comparison, compliance requirements)
├── data-model.md        # Phase 1 output (SmsPreference, SmsMessage, SmsTemplate schemas)
├── quickstart.md        # Phase 1 output (10-minute Twilio setup guide)
└── contracts/           # Phase 1 output (SMS API endpoints, webhook specifications)
    ├── sms-api.md       # POST /api/sms/send, POST /api/sms/broadcast
    ├── preferences-api.md  # GET/PUT /api/sms/preferences, POST /api/sms/verify
    ├── webhooks-api.md  # POST /api/webhooks/twilio/status, POST /api/webhooks/twilio/incoming
    └── templates-api.md # GET/POST /api/sms/templates, GET /api/sms/templates/{id}
```

### Source Code (repository root)

```
# Web application structure (backend + frontend)
api/                               # Backend FastAPI application
├── services/
│   └── sms_service.py            # SMSService class (Twilio integration)
├── routers/
│   ├── sms.py                    # SMS API endpoints (send, broadcast, templates)
│   └── webhooks.py               # Twilio webhook handlers (status, incoming)
├── models.py                     # Add: SmsPreference, SmsMessage, SmsTemplate, SmsUsage
├── tasks/
│   └── sms_tasks.py              # Celery tasks (async message sending, reminders)
└── utils/
    ├── rate_limiter.py           # Redis-based rate limiting (3 msgs/day/volunteer)
    └── quiet_hours.py            # Timezone-aware quiet hours enforcement

frontend/                          # Frontend SPA
├── js/
│   ├── sms-preferences.js        # SMS preference management UI
│   └── sms-admin.js              # Admin broadcast/template management UI
└── css/
    └── sms-preferences.css       # SMS preference UI styles

tests/
├── unit/
│   ├── test_sms_service.py       # Unit tests for SMSService (mocked Twilio)
│   ├── test_rate_limiter.py      # Rate limiting logic tests
│   └── test_quiet_hours.py       # Quiet hours calculation tests
├── integration/
│   ├── test_sms_api.py           # SMS API endpoint tests (Twilio sandbox)
│   ├── test_twilio_webhooks.py   # Webhook processing tests
│   └── test_celery_tasks.py      # Async task execution tests
└── e2e/
    ├── test_sms_preferences.py   # E2E: Phone verification, preference saving
    └── test_sms_broadcast.py     # E2E: Admin broadcast message sending

migrations/                        # Alembic database migrations
└── versions/
    └── add_sms_tables.py         # Add SMS-related tables to database
```

**Structure Decision**: Web application architecture selected because SMS notification system requires both backend service integration (Twilio API, Celery task queue, Redis rate limiting) and frontend UI components (volunteer preference management in user app, administrator broadcast messaging in admin console). Backend implements SMS service layer with async message sending via Celery workers, webhook handlers for delivery status updates and incoming SMS replies, and rate limiting enforcement. Frontend provides preference configuration UI for volunteers to verify phone numbers and select notification types, plus admin UI for broadcast messaging and template management.

## Complexity Tracking

*No constitution violations requiring justification.*

## Next Steps

**Phase 0: Research (Next)**
- Compare SMS gateway providers (Twilio vs. alternatives: Amazon SNS, Plivo, MessageBird)
- Document TCPA compliance requirements for SMS opt-in/opt-out
- Research two-way SMS reply patterns (YES/NO confirmation workflows)
- Analyze SMS rate limiting best practices (carrier limits, spam prevention)
- Investigate quiet hours implementation with timezone handling
- Research message template systems with variable substitution
- Analyze SMS cost optimization strategies (message length, delivery timing)
- Document Twilio webhook security (request validation, signature verification)

**Phase 1: Design & Contracts**
- Generate `data-model.md` with database schemas for SmsPreference, SmsMessage, SmsTemplate, SmsUsage entities
- Create API contracts in `contracts/` directory:
  - `sms-api.md`: Message sending endpoints (POST /api/sms/send, POST /api/sms/broadcast)
  - `preferences-api.md`: Preference management (GET/PUT /api/sms/preferences, POST /api/sms/verify)
  - `webhooks-api.md`: Twilio webhook handlers (POST /webhooks/twilio/status, POST /webhooks/twilio/incoming)
  - `templates-api.md`: Template management (GET/POST /api/sms/templates)
- Generate `quickstart.md` with 10-minute Twilio setup guide (test credentials, webhook configuration, first SMS)
- Update agent context by running `.specify/scripts/bash/update-agent-context.sh claude`

**Phase 2: Task Breakdown**
- Run `/speckit.tasks` to generate implementation tasks organized by user story
- Prioritize P1 tasks: Assignment notifications, preference management
- Defer P3 tasks: Cost management, template library, testing mode

---

**Constitution Re-check Required**: After Phase 1 design complete, verify no new complexity introduced that violates simplicity or test-first principles.
